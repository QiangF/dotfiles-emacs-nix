* Appearance
** Highlight current line

#+BEGIN_SRC emacs-lisp :results none
(hook! 'prog-mode-hook #'hl-line-mode)
#+END_SRC

** Hide extraneous stuff
  
Configures and minimalizes the main Emacs frame

#+BEGIN_SRC emacs-lisp :results none
(setq inhibit-startup-message t)
(scroll-bar-mode -1)
(tool-bar-mode -1)
(menu-bar-mode -1)
(set-fringe-mode 10)
#+END_SRC

** Theme

#+BEGIN_SRC emacs-lisp :results none
(use-package doom-themes
  :straight t
  :config
  (setq doom-themes-enable-bold t
        doom-themes-enable-italic t)

  (load-theme 'doom-dracula t))
#+END_SRC

** Visual page break
#+BEGIN_SRC emacs-lisp :results none
(use-package page-break-lines
  :defer t
  :straight t
  :config
  (global-page-break-lines-mode))
#+END_SRC
* Features
** Auto scroll *Messages* buffer
#+BEGIN_SRC emacs-lisp :results none :tangle no
(hook! 'post-command-hook
        (lambda ()
            (let ((messages (get-buffer "*Messages*")))
              (unless (eq (current-buffer) messages)
                (with-current-buffer messages
                  (goto-char (point-max)))))))
#+END_SRC
** Scratch buffer

Prevent the scratch buffer from being deleted

#+BEGIN_SRC emacs-lisp
(with-current-buffer "*scratch*" (emacs-lock-mode 'kill))
#+END_SRC

** Dashboard

#+BEGIN_SRC emacs-lisp :results none
(use-package dashboard
  :straight t
  :config
  (setq initial-buffer-choice (lambda () (get-buffer-create "*dashboard*"))
        dashboard-banners-directory (pg/config-file "banners/")
        dashboard-startup-banner (+ 1 (random 3))
        dashboard-filter-agenda-entry #'dashboard-filter-agenda-by-todo
        dashboard-items '((projects . 5)
                          (recents . 10)
                          (agenda . 15)))

  (dashboard-setup-startup-hook)

  (hook! 'dashboard-after-initialize-hook #'(lambda ()
                                              (with-current-buffer "*dashboard*" (emacs-lock-mode 'kill))))

  (defun dashboard-refresh-buffer-silent ()
    "Refresh buffer in background."
    (interactive)
    (let ((dashboard-force-refresh t)) (dashboard-insert-startupify-lists)))
  
  (defun dashboard-switch ()
    "Switch to dashboard buffer"
    (interactive)
    (switch-to-buffer dashboard-buffer-name))
  
  (pg/leader "o d" '(dashboard-switch :which-key "dashboard"))

  :general
  (:states 'normal
   :keymaps 'dashboard-mode-map
   "q" nil))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(setq dashboard-set-navigator t)
(setq dashboard-navigator-buttons
      `(((nil "Home Assistant" "Home Assistant" (lambda (&rest _) (hass/query-entities))))))
#+END_SRC

** Which-key

A handy popup to show keybinds.

#+BEGIN_SRC emacs-lisp :results none
(use-package which-key
  :straight t
  :config
  (setq which-key-idle-delay 1)
  (which-key-mode 1))
#+END_SRC

** Completion framework
*** Ivy

Ivy config just in case I wanna use it for something. Disabled.

#+BEGIN_SRC emacs-lisp :results none :tangle no
;; Better fuzzy search. Unintuitively intercepts `ivy--regex-fuzzy` below
(use-package flx
  :straight t)

(use-package ivy
  :straight t
  :init
  (ivy-mode 1)

  :config
  (setq ivy-use-virtual-buffers t
        ivy-initial-inputs-alist nil
        ivy-re-builders-alist '((t . ivy--regex-fuzzy)))

  :general
;; Minibuffer Evil movement keys
  (:keymaps 'ivy-minibuffer-map
    "C-S-k" 'ivy-scroll-down-command
    "C-S-j" 'ivy-scroll-up-command
    "C-k" 'ivy-previous-line
    "C-j" 'ivy-next-line))

(use-package counsel
  :straight t
  :after ivy
  :init
  (counsel-mode 1)

  :config
  (setq counsel-describe-variable-function 'helpful-variable
        counsel-describe-function-function 'helpful-function)

  ;; Redefine find file functions to counsel variants
  (defun pg/find-file-in-profile-dir ()
    (interactive)
    (counsel-find-file pg/config-dir))
  
  (defun pg/find-file-in-home-dir ()
    (interactive)
    (counsel-find-file "~"))
  
  (defun pg/find-file-in-root-dir ()
    (interactive)
    (counsel-find-file "/"))

  (defun pg/project-search-thing-at-point ()
    (interactive)
    (counsel-rg (thing-at-point 'symbol)))

  (pg/leader
    "p s" '(counsel-rg :which-key "search")
    "f f" '(counsel-find-file :which-key "in profile")
    "f c" '(pg/find-file-in-profile-dir :which-key "in config")
    "f ~" '(pg/find-file-in-home-dir :which-key "in home")
    "f /" '(pg/find-file-in-root-dir :which-key "in root")
    "f r" '(counsel-recentf :which-key "find recent")
    "p S" '(pg/project-search-thing-at-point :which-key "search this")))

(use-package ivy-rich
  :straight t
  :after ivy
  :init
  (ivy-rich-mode 1))

(use-package swiper
  :straight t
  :after ivy
  :config
  (pg/leader
    "s b" '(swiper :which-key "buffer")))
#+END_SRC

*** Vertico

#+BEGIN_SRC emacs-lisp :results none
(use-package vertico
  :straight t
  :init
  (vertico-mode 1)

  :config
  ;; Redefine find file functions to support vertico
  (defun pg/find-file-in-profile-dir ()
    (interactive)
    (ido-find-file-in-dir pg/config-dir))
  
  (defun pg/find-file-in-home-dir ()
    (interactive)
    (ido-find-file-in-dir "~"))
  
  (defun pg/find-file-in-org-dir ()
    (interactive)
    (ido-find-file-in-dir org-directory))
  
  (defun pg/find-file-in-root-dir ()
    (interactive)
    (ido-find-file-in-dir "/"))

  (defun pg/project-search-thing-at-point ()
    (interactive)
    (consult-ripgrep projectile-project-root (thing-at-point 'symbol)))

  (pg/leader
    "f o" '(pg/find-file-in-org-dir :which-key "in org")
    "f c" '(pg/find-file-in-profile-dir :which-key "in config")
    "f ~" '(pg/find-file-in-home-dir :which-key "in home")
    "f /" '(pg/find-file-in-root-dir :which-key "in root")
    "f f" '(find-file :which-key "file")
    "p S" '(pg/project-search-thing-at-point :which-key "search this"))

  :general
  (:keymaps 'minibuffer-local-map
    "C-S-k" 'scroll-down-command
    "C-S-j" 'scroll-up-command
    "C-k" 'previous-line
    "C-j" 'next-line
    "C-l" 'vertico-insert))
#+END_SRC

Consult offers ~ivy-counsel~ like function for ~Vertico~.

#+BEGIN_SRC emacs-lisp
(use-package consult
  :straight t
  :after vertico
  :config
  
  (setq consult-project-root-function #'projectile-project-root)
  
  (pg/leader
    "b b" '(consult-buffer :which-key "buffer")
    "b o" '(consult-buffer-other-frame :which-key "buffer-other")
    "s b" '(consult-line :which-key "buffer")
    "s p" '(consult-line-multi :which-key "project")
    "s r" '(consult-ripgrep :which-key "regex")
    "f r" '(consult-recent-file :which-key "recent"))
  (recentf-mode 1))
    
(use-package consult-lsp
  :straight t
  :after consult lsp
  :config
  (pg/leader
    :keymaps 'lsp-mode-map
    "s e" '(consult-lsp-diagnostics :which-key "errors")))
#+END_SRC

~marginalia~ gives a prettier, more informative minibuffer completion

#+BEGIN_SRC emacs-lisp
(use-package marginalia
  :straight t
  :after vertico
  :init
  (marginalia-mode 1))
#+END_SRC

*** Style

~orderless~ allows completion chunks (space delimited) to be search out of order. In other words, a
query for =some function= will return the same results as =function some= with possibly a different
sort order based on accuracy.

#+BEGIN_SRC emacs-lisp
(use-package orderless
  :straight t
  :config
  (setq completion-styles '(basic orderless partial-completion)))
#+END_SRC

*** Save histry between sessions

#+BEGIN_SRC emacs-lisp :results none
(use-package savehist
  :straight t
  :init
  (savehist-mode))
#+END_SRC

** Modeline

#+BEGIN_SRC emacs-lisp :results none
(use-package doom-modeline
  :straight t
  :config
  (doom-modeline-mode 1))
#+END_SRC

** Perspectives

#+BEGIN_SRC emacs-lisp :results none
(use-package persp-mode
  :straight t
  :config
  (setq persp-auto-resume-time -1)
  (add-to-list 'recentf-exclude (concat user-emacs-directory "persp-confs/persp-auto-save") t)

  ;; Modified from Doom's `+workspace--tabline`
  (defun persp--format-tab (label active) 
    (propertize label
      'face (if active
        'doom-modeline-panel
        'doom-modeline-bar-inactive)))

  (defun persp-list () 
  "Display a list of perspectives"
    (interactive)
    (message "%s"
      (let ((names persp-names-cache)
            (current-name (safe-persp-name
                            (get-current-persp
                              (selected-frame)
                              (selected-window)))))
        (mapconcat
         #'identity
          (cl-loop for name in names
                   for i to (length names)
                   collect
                   (persp--format-tab
                     (format " %d:%s " (1+ i) name)
                     (equal current-name name)))
         nil))))

  ;; Show list of perspectives after switching
  (advice-add 'persp-next :after 'persp-list)
  (advice-add 'persp-prev :after 'persp-list)
  
  (pg/leader
    :keymaps 'persp-mode-map
    "b b" '(persp-switch-to-buffer :which-key "buffer")
    "TAB" '(:which-key "perspectives")
    "TAB TAB" '(persp-list :which-key "list")
    "TAB s" '(persp-switch :which-key "switch")
    "TAB a" '(persp-add-buffer :which-key "add buffer")
    "TAB x" '(persp-remove-buffer :which-key "remove buffer")
    "TAB d" '(persp-kill :which-key "kill persp")
    "TAB r" '(persp-rename :which-key "rename")
    "TAB n" '(persp-add-new :which-key "new")
    "TAB l" '(persp-next :which-key "next persp")
    "TAB h" '(persp-prev :which-key "prev persp"))

  (persp-mode))
  
#+END_SRC
** Help!

#+BEGIN_SRC emacs-lisp :results none
(use-package helpful
  :straight t
  :config
  (pg/leader
    "h f" '(helpful-function :which-key "function")
    "h v" '(helpful-variable :which-key "variable")
    "h m" '(helpful-macro :which-key "macro")
    "h V" '(apropos-value :which-key "value")
    "h ." '(helpful-at-point :which-key "this")
    "h k" '(helpful-key :which-key "key")))
#+END_SRC

